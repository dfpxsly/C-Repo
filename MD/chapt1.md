
##shared_ptr的线程安全##
  多个线程能在 shared_ptr 的不同实例上调用所有成员函数（包含复制构造函数与复制赋值）而不附加同步，即使这些实例是副本，且共享同一对象的所有权。若多个执行线程访问同一 shared_ptr 而不同步，且任一线程使用 shared_ptr 的非 const 成员函数，则将出现数据竞争
 
 1. shared_ptr 本身不是100%线程安全
 2. 引用计数是原子化操作，但对象的读写不是
 3. 多线程访问同一shared_ptr,用mutex保护;


###注意###
 1. 意外延长的生命周期（如bind())
 2. 函数参数，最好传const reference,因为拷贝开销大
 3. 析构动作在创建时被捕获
    * 虚析构不再是必须的
    *  `shared_ptr<void> `可以持有任何对象，且能安全的释放
    * shared_ptr 对象可以安全的跨越模块边界 **？**
    * 二进制兼容性**？**
    * 析构动作可以定制:用 delete 表达式或在构造期间提供给 shared_ptr 的定制删除器销毁对象;
 4. 析构所在的线程：对象的析构是同步的，当最后一个指向x的shared_ptr离开其作用域时，x会同时在同一个线程析构。（若析构比较耗时，可以设计单独的线程专门析构）
 5. 现成的RAII handle;但应注意不要出现循环引用；
##对象池##

